/*		Ruairi Doherty
 * 		Created on 29/01/2020
 * 		Final Year Project - Remote-Robot
 * 		Robot Module
 */

#include "freertos/FreeRTOS.h"
#include "esp_wifi.h"
#include "esp_system.h"
#include "esp_event.h"
#include <esp_log.h>
#include <string.h>
#include "nvs_flash.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/ledc.h"
#include "driver/i2c.h"
#include "sdkconfig.h"
#include "esp_netif.h"
#include "esp_now.h"
#include "freertos/queue.h"

uint8_t gloveModuleAddress[] = { 0x3C, 0x71, 0xBF, 0xA1, 0x34, 0x88 };

QueueHandle_t dataQueue = NULL;

void on_data_receive(const uint8_t* mac_addr, int16_t* data, int len)
{
	int16_t dataRx[4];
	memcpy(&dataRx, data, sizeof(dataRx));
	printf("Bytes received from Glove module: %d\n", len);
	xQueueSend(dataQueue, &dataRx, 0);
}

void servo_write(void* pvParameters)
{
	int16_t dataRx[4];
	int16_t incomingX, incomingY, incomingZ, incomingFlex;

	int16_t gripperValue = 0, rollValue = 0;

	/*---Gripper Servo Configuration---*/
	ledc_timer_config_t gripper_timer_conf;
	gripper_timer_conf.bit_num = LEDC_TIMER_15_BIT;
	gripper_timer_conf.freq_hz = 50;
	gripper_timer_conf.speed_mode = LEDC_HIGH_SPEED_MODE;
	gripper_timer_conf.timer_num = LEDC_TIMER_0;
	ledc_timer_config(&gripper_timer_conf);
	ledc_channel_config_t gripper_ledc_conf;
	gripper_ledc_conf.channel = LEDC_CHANNEL_0;
	gripper_ledc_conf.duty = gripperValue;
	gripper_ledc_conf.gpio_num = 16;
	gripper_ledc_conf.intr_type = LEDC_INTR_DISABLE;
	gripper_ledc_conf.speed_mode = LEDC_HIGH_SPEED_MODE;
	gripper_ledc_conf.timer_sel = LEDC_TIMER_0;
	ledc_channel_config(&gripper_ledc_conf);

	/*---Roll Servo Configuration---*/
	ledc_timer_config_t roll_timer_conf;
	roll_timer_conf.bit_num = LEDC_TIMER_15_BIT;
	roll_timer_conf.freq_hz = 50;
	roll_timer_conf.speed_mode = LEDC_HIGH_SPEED_MODE;
	roll_timer_conf.timer_num = LEDC_TIMER_1;
	ledc_timer_config(&roll_timer_conf);
	ledc_channel_config_t roll_ledc_conf;
	roll_ledc_conf.channel = LEDC_CHANNEL_1;
	roll_ledc_conf.duty = gripperValue;
	roll_ledc_conf.gpio_num = 3;
	roll_ledc_conf.intr_type = LEDC_INTR_DISABLE;
	roll_ledc_conf.speed_mode = LEDC_HIGH_SPEED_MODE;
	roll_ledc_conf.timer_sel = LEDC_TIMER_1;
	ledc_channel_config(&roll_ledc_conf);

	for(;;) {
		//Wait forever for incoming data
		if(xQueueReceive(dataQueue, &dataRx, portMAX_DELAY)) {
			incomingX = dataRx[0];
			incomingY = dataRx[1];
			incomingZ = dataRx[2];
			incomingFlex = dataRx[3];

			gripperValue = incomingFlex;
			rollValue = incomingY;

			//printf("accelX: %d, accelY: %d, accelZ: %d, flexAvg: %d\n", incomingX, incomingY, incomingZ, incomingFlex);
			printf("rollVal: %d\n", rollValue);
			ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0, gripperValue);
			ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1, rollValue);
			ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0);
			ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1);
		}
		vTaskDelay(pdMS_TO_TICKS(250));
	}
	vTaskDelete(NULL);
}

void wifi_init()
{
	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
	ESP_ERROR_CHECK(esp_wifi_start());

	ESP_ERROR_CHECK(esp_now_init());
	esp_now_peer_info_t peerInfo; // @suppress("Type cannot be resolved")
	memcpy(peerInfo.peer_addr, gloveModuleAddress, 6); // @suppress("Field cannot be resolved")
	peerInfo.ifidx = WIFI_IF_STA; // @suppress("Field cannot be resolved")
	peerInfo.channel = 0; // @suppress("Field cannot be resolved")
	peerInfo.encrypt = false; // @suppress("Field cannot be resolved")
	if(esp_now_add_peer(&peerInfo) != ESP_OK)
		printf("Failed to add peer\n");
	else
		printf("Successfully added peer\n");

	//4 items 8 bytes each
	dataQueue = xQueueCreate(4, 8);

	esp_now_register_recv_cb(on_data_receive);
}

void app_main(void)
{
	nvs_flash_init();
	wifi_init();
	xTaskCreate(&servo_write, "servo_write", 2048, NULL, 5, NULL);
}
