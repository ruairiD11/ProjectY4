/*		Ruairi Doherty
 * 		26/01/2020
 * 		Final Year Project - Remote-Robot
 * 		Glove Module
 */

#include "freertos/FreeRTOS.h"
#include "esp_wifi.h"
#include "esp_system.h"
#include "esp_event.h"
#include <esp_log.h>
#include <string.h>
#include "nvs_flash.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/ledc.h"
#include <driver/i2c.h>
#include "sdkconfig.h"
#include "esp_netif.h"
#include "esp_now.h"

#define PIN_SDA 21
#define PIN_CLK 22
#define I2C_ADDRESS 0x68 // I2C address of MPU6050

#define MPU6050_ACCEL_XOUT_H 0x3B
#define MPU6050_PWR_MGMT_1   0x6B

uint8_t robotModuleAddress[] = { 0xb4, 0xe6, 0x2d, 0xe3, 0xd2, 0x6d };

int16_t dataTx[6];

void on_data_sent(const uint8_t* mac_addr, esp_now_send_status_t status)
{
	for(;;)
	{
		printf("Last Packet Send Status: ");
		if (status == ESP_NOW_SEND_SUCCESS) {
			printf("Delivery Success\n");
		}
		else if (status == ESP_NOW_SEND_FAIL) {
			printf("Delivery Fail\n");
		}
		vTaskDelay(pdMS_TO_TICKS(1000));
	}
	vTaskDelete(NULL);
}

void wifi_init(void* pvParameters)
{
	wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
	ESP_ERROR_CHECK(esp_wifi_init(&cfg));
	ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
	ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
	ESP_ERROR_CHECK(esp_wifi_start());

	ESP_ERROR_CHECK(esp_now_init());
	esp_now_register_send_cb(on_data_sent);

	esp_now_peer_info_t peerInfo;
	memcpy(peerInfo.peer_addr, robotModuleAddress, 6);
	peerInfo.ifidx = WIFI_IF_STA;
	peerInfo.channel = 0;
	peerInfo.encrypt = false;
	if(esp_now_add_peer(&peerInfo) != ESP_OK) {
		printf("Failed to add peer\n");
	}
	else {
		printf("Successfully added peer\n");
	}

	for(;;) {
		printf("%d %d %d %d %d %d \n", dataTx[0], dataTx[1], dataTx[2], dataTx[3], dataTx[4], dataTx[5]);

		vTaskDelay(pdMS_TO_TICKS(3000));
		esp_err_t result = esp_now_send(robotModuleAddress, (int16_t*)&dataTx, sizeof(dataTx));

		if (result == ESP_OK) {
			printf("Sent with success\n");
		}
		else {
			printf("Error sending the data\n");
		}
		vTaskDelay(pdMS_TO_TICKS(1000));
	}
	vTaskDelete(NULL);
}

/*void read_flex(void* pvParameters)
{
	adc1_config_width(ADC_WIDTH_12Bit);
	adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_11db); //GPIO 36 - THIRD
	adc1_config_channel_atten(ADC1_CHANNEL_3, ADC_ATTEN_11db); //GPIO 39 - MIDDLE
	adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_11db); //GPIO 34 - INDEX

	for(;;) {
		int index = adc1_get_raw(ADC1_CHANNEL_6);
		int middle = adc1_get_raw(ADC1_CHANNEL_3);
		int third = adc1_get_raw(ADC1_CHANNEL_0);
		if(middle == 4095)
			middle = 2100;
		int sum = index+middle+third;
		avg = sum/3;


		printf("Index: %d   Middle: %d   Third: %d\n", index, middle, third);
		vTaskDelay(pdMS_TO_TICKS(1000));
	}
	vTaskDelete(NULL);
}*/

void read_accelerometer(void* pvParameters)
{
	i2c_config_t conf;
	conf.mode = I2C_MODE_MASTER;
	conf.sda_io_num = PIN_SDA;
	conf.scl_io_num = PIN_CLK;
	conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
	conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
	conf.master.clk_speed = 100000;
	i2c_param_config(I2C_NUM_0, &conf);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);

	i2c_cmd_handle_t cmd;
	vTaskDelay(200/portTICK_PERIOD_MS);

	cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (I2C_ADDRESS << 1) | I2C_MASTER_WRITE, 1);
	i2c_master_write_byte(cmd, MPU6050_ACCEL_XOUT_H, 1);
	i2c_master_stop(cmd);
	i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

	cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (I2C_ADDRESS << 1) | I2C_MASTER_WRITE, 1);
	i2c_master_write_byte(cmd, MPU6050_PWR_MGMT_1, 1);
	i2c_master_write_byte(cmd, 0, 1);
	i2c_master_stop(cmd);
	i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

	uint8_t data[14];

	for(;;) {
		// Tell the MPU6050 to position the internal register pointer to register
		// MPU6050_ACCEL_XOUT_H.
		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (I2C_ADDRESS << 1) | I2C_MASTER_WRITE, 1);
		i2c_master_write_byte(cmd, MPU6050_ACCEL_XOUT_H, 1);
		i2c_master_stop(cmd);
		i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000/portTICK_PERIOD_MS);
		i2c_cmd_link_delete(cmd);

		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (I2C_ADDRESS << 1) | I2C_MASTER_READ, 1);

		i2c_master_read_byte(cmd, data,   0);
		i2c_master_read_byte(cmd, data+1, 0);
		i2c_master_read_byte(cmd, data+2, 0);
		i2c_master_read_byte(cmd, data+3, 0);
		i2c_master_read_byte(cmd, data+4, 0);
		i2c_master_read_byte(cmd, data+5, 1);

		i2c_master_stop(cmd);
		i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000/portTICK_PERIOD_MS);
		i2c_cmd_link_delete(cmd);

		//2 Bytes each - 12 Bytes
		dataTx[0] = (data[0] << 8);
		dataTx[1] = data[1];
		dataTx[2] = (data[2] << 8);
		dataTx[3] = data[3];
		dataTx[4] = (data[4] << 8);
		dataTx[5] = data[5];

		vTaskDelay(pdMS_TO_TICKS(1000));
	}
	vTaskDelete(NULL);
}

void app_main(void)
{
	nvs_flash_init();
	xTaskCreate(&wifi_init, "wifi_init", 4096, NULL, 5, NULL);
	//xTaskCreate(&read_flex, "read_flex", 2048, NULL, 4, NULL);
	xTaskCreate(&read_accelerometer, "read_accelerometer", 2048, NULL, 4, NULL);
}
